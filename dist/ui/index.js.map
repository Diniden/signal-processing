{"version":3,"file":"index.js","sources":["../../ui/src/FIR.ts","../../ui/src/pascal-triangle.ts","../../ui/src/gaussian-blur.ts","../../ui/src/scale-linear.ts","../../ui/src/perlin-noise.ts"],"sourcesContent":["import { Vec2 } from \"./types\";\n\n/**\n * Performs a frequency filtration across a provided streamed in signal.\n * This filter can be adjusted via the seed values provided.\n */\nexport class FIRFilter {\n  coefficients: number[];\n  filter: number[];\n\n  /**\n   * The seed values work in tuples [FIR filter coefficient, starting bias];\n   * When normalize is activated, the seed values are normalized to the provided value.\n   * When normalize is a value of 1, this behaves like a low pass FIR filter.\n   */\n  constructor(seedValues: Vec2[], normalize?: number) {\n    this.coefficients = seedValues.map((seed) => seed[0]);\n    this.filter = seedValues.map((seed) => seed[1]);\n\n    if (normalize !== undefined) {\n      let total = 0;\n      this.coefficients.forEach((c) => (total += c));\n      this.coefficients = this.coefficients.map((value) => {\n        return (value / total) * normalize;\n      });\n    }\n  }\n\n  /**\n   * Reset the filter to have all of it's filter values set to the provided value\n   */\n  reset(value: number) {\n    this.filter = this.filter.map(() => value);\n  }\n\n  /**\n   * This streams in a value into the filter and outputs the next computed value\n   */\n  stream(value: number) {\n    let out = 0;\n    this.filter.pop();\n    this.filter.unshift(value);\n\n    for (let i = 0, end = this.coefficients.length; i < end; ++i) {\n      out += this.coefficients[i] * this.filter[i];\n    }\n\n    this.filter.shift();\n    this.filter.unshift(out);\n\n    return out;\n  }\n\n  /**\n   * Runs a list of values through the filter and returns an array of each step\n   */\n  run(start: number, values: number[]) {\n    const current = this.filter.slice(0);\n    const toProcess = values.slice(0);\n    this.reset(start);\n    const out: number[] = [];\n\n    while (toProcess.length > 0) {\n      out.push(this.stream(toProcess.shift() || 0));\n    }\n\n    // Reset the filter back to where it was\n    this.filter = current;\n\n    return out;\n  }\n}\n","export class PascalTriangle {\n  /** Contains the triangles elements [[1], [1, 1], [1, 2, 1], etc] */\n  elements: number[][] = [];\n\n  constructor(levels: number) {\n    if (levels === 0) return;\n    const elements: number[][] = [[1]];\n    const _levels = levels - 1;\n\n    // i will be the index pointing to the previous row\n    for (let i = 0; i < _levels; ++i) {\n      const previous = elements[i];\n      const row = [1];\n\n      for (let k = 0, endk = previous.length - 1; k < endk; ++k) {\n        row.push(previous[k] + previous[k + 1]);\n      }\n\n      row.push(1);\n      elements.push(row);\n    }\n\n    this.elements = elements;\n  }\n\n  /**\n   * Tries to generate a gaussian kernal based on the pascal triangle where the kernal has so many elements\n   * To get a higher quality kernal trim off the ends of the triangle's row but keep the kernal number.\n   * This causes a deeper triangle to be calculated.\n   */\n  gaussianKernal(size: number, trim: number) {\n    const toTrim = trim * 2;\n    let row: number[] = [];\n\n    // Loop until we hit a row with enough elements to make the kernal\n    for (\n      let i = 0, end = this.elements.length;\n      i < end && this.elements[i].length - toTrim <= size;\n      ++i\n    ) {\n      row = this.elements[i];\n    }\n\n    // Make sure the elements matches the requested elements size exactly\n    if (row.length - toTrim !== size) {\n      console.warn(\n        \"Error in pascal triangle gaussian kernal\",\n        \"Requested size\",\n        size,\n        \"Row\",\n        row,\n        \"Trim amount\",\n        trim,\n        \"Elements\",\n        this.elements\n      );\n    }\n\n    // Copy and remove trimed elements\n    let kernal = row.slice(trim, row.length - trim);\n    // Get the new total of the row\n    const total = kernal.reduce((prev, next) => next + prev, 0);\n    // Normalize the kernal\n    kernal = kernal.map((value) => value / total);\n\n    return {\n      kernal,\n      total,\n    };\n  }\n}\n","import { PascalTriangle } from \"./pascal-triangle\";\n\nexport interface IGaussianBlurOptions {\n  /** Number of samples taken per data slot */\n  kernalSize: number;\n  /** Number of times the blur is applied */\n  passes: number;\n}\n\nconst { min, max } = Math;\n\nfunction clamp(val: number, minVal: number, maxVal: number) {\n  return max(min(val, maxVal), minVal);\n}\n\n/**\n * Performs a gaussian blur on a set of numerical data.\n */\nexport class GaussianBlur {\n  // This is a blur kernal used for blending\n  private kernal: number[] = [];\n  // These are the options for the blur operation\n  options: IGaussianBlurOptions;\n\n  constructor(options: IGaussianBlurOptions) {\n    this.options = options;\n    this.update(options);\n  }\n\n  /**\n   * Applies the blur to the input data, returns a blurred version without affecting the source.\n   */\n  generate(\n    data: number[][],\n    offsetLeft = 0,\n    offsetTop = 0,\n    offsetRight = 0,\n    offsetBottom = 0\n  ) {\n    if (!data || !data[0] || !data[0].length) return data;\n\n    const { passes } = this.options;\n    const kernal = this.kernal;\n    const outPass = data.map((col) => col.slice(0));\n    const width = data.length;\n    const height = data[0].length;\n\n    const offsets: { [key: number]: number[] } = {\n      1: [0],\n      3: [-1, 0, 1],\n      5: [-2, -1, 0, 1, 2],\n      7: [-3, -2, -1, 0, 1, 2, 3],\n      9: [-4, -3, -2, -1, 0, 1, 2, 3, 4],\n    };\n    const offset = offsets[kernal.length];\n\n    if (!offset) {\n      console.warn(\"No offset suitable for kernal size\");\n      return data;\n    }\n\n    // Instantiate our vertical pass so we don't recreate every pass\n    const verticalPass: number[][] = [];\n    for (let x = 0; x < width; ++x) {\n      verticalPass.push([]);\n    }\n\n    for (let blurCount = 0; blurCount < passes; ++blurCount) {\n      // After the octaves have been loaded in, we can blur filter the result\n      let value;\n      let sample;\n\n      // Vertical Gaussian blur pass\n      for (let x = offsetLeft, endx = width - offsetRight; x < endx; ++x) {\n        const outCol = verticalPass[x];\n        const inCol = outPass[x];\n\n        for (let y = offsetTop, endy = height - offsetBottom; y < endy; ++y) {\n          value = 0;\n\n          for (let k = 0, endk = kernal.length; k < endk; ++k) {\n            sample = clamp(y + offset[k], 0, endy - 1);\n            value += (inCol[sample] || 0) * kernal[k];\n          }\n\n          outCol[y] = value;\n        }\n      }\n\n      // Horizontal Gaussian blur into our perlin data\n      for (let x = offsetLeft, endx = width - offsetRight; x < endx; ++x) {\n        const outCol = outPass[x];\n\n        for (let y = offsetTop, endy = height - offsetBottom; y < endy; ++y) {\n          value = 0;\n\n          for (let k = 0, endk = kernal.length; k < endk; ++k) {\n            sample = clamp(x + offset[k], 0, endx - 1);\n            value += ((verticalPass[sample] || [])[y] || 0) * kernal[k];\n          }\n\n          outCol[y] = value;\n        }\n      }\n    }\n\n    return outPass;\n  }\n\n  update(options: Partial<IGaussianBlurOptions>) {\n    Object.assign(this.options, options);\n\n    if (options.kernalSize) {\n      // This is a blur kernal that will be used for sampling the zoomed in octaves\n      this.kernal = new PascalTriangle(15).gaussianKernal(\n        options.kernalSize,\n        2\n      ).kernal;\n    }\n  }\n}\n","import { Vec2 } from \"./types\";\n\nexport function scaleLinear(domain: Vec2, range: Vec2) {\n  return function (x: number) {\n    return (\n      ((x - domain[0]) / (domain[1] - domain[0])) *\n      (range[1] - range[0] + range[0])\n    );\n  };\n}\n","import { GaussianBlur } from \"./gaussian-blur\";\nimport { scaleLinear } from \"./scale-linear\";\nimport { Vec2 } from \"./types\";\n\nconst { abs, floor, max, min, random } = Math;\n\nexport interface IPerlinOptions {\n  /** Output width */\n  width: number;\n  /** Output height */\n  height: number;\n  /** The amount of blurring to apply to the combined octaves */\n  blendPasses: number;\n  /**\n   * An octave is the start of perlin noise with a gaussian noise map. Each octave should be smaller\n   * than the end result. The octave is then scaled up then averaged with the\n   * other octaves. Octaves closer to the output size creates greater detail in regions, while\n   * octaves that are smaller creates larger features.\n   *\n   * Octaves are in the format [width, height]\n   */\n  octaves: Vec2[];\n  /**\n   * This sets the values that should appear within the perlin dataset.\n   */\n  valueRange: Vec2;\n}\n\n/**\n * This generates a 2d plane of perlin noise that is gray scale with values\n * that are 0 - 1.\n */\nexport class PerlinNoise {\n  /** The blurring kernal used to blur the data */\n  private blur: GaussianBlur;\n  /** The perlin data with values 0 - 1 */\n  data!: number[][];\n  /** Used for debug rendering the output */\n  private debugContext!: HTMLCanvasElement;\n  /** The options used to construct the data */\n  options: IPerlinOptions;\n\n  get width() {\n    return this.options.width;\n  }\n\n  get height() {\n    return this.options.height;\n  }\n\n  /**\n   * Provide the output size, and the size of the octaves generated.\n   */\n  constructor(options: IPerlinOptions) {\n    this.options = options;\n    this.blur = new GaussianBlur({\n      passes: options.blendPasses,\n      kernalSize: 9,\n    });\n\n    this.update(options);\n  }\n\n  /**\n   * Generates a new perlin dataset\n   */\n  async generate() {\n    const { width, height, octaves, valueRange } = this.options;\n    // This will contain the end perlin result\n    let perlin: number[][] = [];\n\n    // Loop through each octave and multiply it into the perlin output\n    octaves.forEach((octave) => {\n      // Start with a smaller sized map of pure gray scale noise\n      const small: number[][] = [];\n      const smallWidth = octave[0];\n      const smallHeight = octave[1];\n      const scaleX = scaleLinear([0, width], [0, smallWidth]);\n      const scaleY = scaleLinear([0, height], [0, smallHeight]);\n\n      // Make the octave base\n      for (let x = 0; x < smallWidth; ++x) {\n        const col: number[] = [];\n        small.push(col);\n\n        for (let y = 0; y < smallHeight; ++y) {\n          col.push(random());\n        }\n      }\n\n      // Sample the octave into the size of the output perlin image\n      for (let x = 0; x < width; ++x) {\n        const col = (perlin[x] = perlin[x] || []);\n\n        for (let y = 0; y < height; ++y) {\n          col[y] = (col[y] || 1) * small[floor(scaleX(x))][floor(scaleY(y))];\n        }\n      }\n    });\n\n    // Run through the perlin noise data with our blur filter\n    perlin = this.blur.generate(perlin);\n\n    // We now normalize the ranges to keep details brighter\n    // We also make the data within each cell reflect the data range\n    // that is specified\n    let maxVal = -1;\n    const range = valueRange[1] - valueRange[0];\n    const base = valueRange[0];\n\n    for (let x = 0; x < width; ++x) {\n      const col = perlin[x];\n\n      for (let y = 0; y < height; ++y) {\n        // First brigten up darkened areas\n        // perlin[x][y] *= 1 / (perlin[x][y] + 1);\n        // Now get the max value\n        maxVal = max(col[y], maxVal);\n      }\n    }\n\n    for (let x = 0; x < width; ++x) {\n      const col = perlin[x];\n\n      for (let y = 0; y < height; ++y) {\n        col[y] /= maxVal;\n        col[y] = col[y] * range + base;\n      }\n    }\n\n    this.data = perlin;\n  }\n\n  /**\n   * Will just ensure the data object is populated with a generation.\n   */\n  async generateOnce() {\n    if (!this.data) {\n      await this.generate();\n    }\n  }\n\n  /**\n   * Retrieves a rectangular sample from the perlin data.\n   * If a threshold is included, absolute values below it will be zero'ed out.\n   */\n  sample(\n    x: number,\n    y: number,\n    width: number,\n    height: number,\n    threshold?: number\n  ) {\n    const out: number[][] = [];\n\n    if (threshold) {\n      for (let i = x, end = min(this.data.length, x + width); i < end; ++i) {\n        out.push(\n          this.data[i]\n            .slice(y, y + height)\n            .map((value) => (abs(value) > threshold ? value : 0))\n        );\n      }\n    } else {\n      for (let i = x, end = min(this.data.length, x + width); i < end; ++i) {\n        out.push(this.data[i].slice(y, y + height));\n      }\n    }\n\n    return out;\n  }\n\n  /**\n   * Update the options for the noise generation.\n   */\n  update(options: Partial<IPerlinOptions>) {\n    Object.assign(this.options, options);\n\n    if (options.blendPasses) {\n      this.blur.update({\n        passes: options.blendPasses,\n      });\n    }\n  }\n\n  /**\n   * Renders a canvas on the screen showing the generated output.\n   */\n  debug(threshold = 0, clear?: boolean) {\n    if (clear) {\n      if (this.debugContext) {\n        this.debugContext.remove();\n      }\n      return;\n    }\n\n    const canvas = document.createElement(\"canvas\").getContext(\"2d\");\n\n    if (canvas) {\n      const { valueRange } = this.options;\n      const element = canvas.canvas;\n      document.getElementsByTagName(\"body\")[0].appendChild(canvas.canvas);\n      const width = (element.width = this.data.length);\n      const height = (element.height = this.data[0].length);\n      const data = canvas.getImageData(0, 0, width, height);\n      let index = 0;\n      const range = valueRange[1] - valueRange[0];\n      const base = valueRange[0];\n\n      if (threshold) {\n        for (let x = 0, end = this.data.length; x < end; ++x) {\n          const col = this.data[x];\n\n          for (let y = 0, endy = col.length; y < endy; ++y) {\n            const val = 255 * (abs(col[y]) > threshold ? 1 : 0);\n            data.data[index * 4] = val;\n            data.data[index * 4 + 1] = val;\n            data.data[index * 4 + 2] = val;\n            data.data[index * 4 + 3] = 255;\n            index++;\n          }\n        }\n      } else {\n        for (let x = 0, end = this.data.length; x < end; ++x) {\n          const col = this.data[x];\n\n          for (let y = 0, endy = col.length; y < endy; ++y) {\n            const val = 255 * ((col[y] - base) / range);\n            data.data[index * 4] = val;\n            data.data[index * 4 + 1] = val;\n            data.data[index * 4 + 2] = val;\n            data.data[index * 4 + 3] = 255;\n            index++;\n          }\n        }\n      }\n\n      canvas.putImageData(data, 0, 0);\n      element.style.position = \"fixed\";\n      element.style.top = \"0px\";\n      element.style.left = \"0px\";\n      element.style.zIndex = \"9999\";\n\n      this.debugContext = element;\n    }\n  }\n}\n"],"names":["FIRFilter","seedValues","normalize","seed","total","c","value","out","i","end","start","values","current","toProcess","PascalTriangle","levels","elements","_levels","previous","row","k","endk","size","trim","toTrim","kernal","prev","next","min","max","clamp","val","minVal","maxVal","GaussianBlur","options","data","offsetLeft","offsetTop","offsetRight","offsetBottom","passes","outPass","col","width","height","offset","verticalPass","x","blurCount","sample","endx","outCol","inCol","y","endy","scaleLinear","domain","range","abs","floor","random","PerlinNoise","octaves","valueRange","perlin","octave","small","smallWidth","smallHeight","scaleX","scaleY","base","threshold","clear","canvas","element","index"],"mappings":"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"}