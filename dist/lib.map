{"version":3,"sources":["FIR.ts","pascal-triangle.ts","gaussian-blur.ts","scale-linear.ts","perlin-noise.ts","index.ts"],"names":[],"mappings":"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","file":"lib.map","sourceRoot":"../src","sourcesContent":["import { Vec2 } from './types';\n\n/**\n * Performs a frequency filtration across a provided streamed in signal.\n * This filter can be adjusted via the seed values provided.\n */\nexport class FIRFilter {\n  coefficients: number[];\n  filter: number[];\n\n  /**\n   * The seed values work in tuples [FIR filter coefficient, starting bias];\n   * When normalize is activated, the seed values are normalized to the provided value.\n   * When normalize is a value of 1, this behaves like a low pass FIR filter.\n   */\n  constructor(seedValues: Vec2[], normalize?: number) {\n    this.coefficients = seedValues.map(seed => seed[0]);\n    this.filter = seedValues.map(seed => seed[1]);\n\n    if (normalize !== undefined) {\n      let total = 0;\n      this.coefficients.forEach(c => (total += c));\n      this.coefficients = this.coefficients.map(\n        value => (value / total) * normalize\n      );\n    }\n  }\n\n  /**\n   * Reset the filter to have all of it's filter values set to the provided value\n   */\n  reset(value: number) {\n    this.filter = this.filter.map(() => value);\n  }\n\n  /**\n   * This streams in a value into the filter and outputs the next computed value\n   */\n  stream(value: number) {\n    let out = 0;\n    this.filter.pop();\n    this.filter.unshift(value);\n\n    for (let i = 0, end = this.coefficients.length; i < end; ++i) {\n      out += this.coefficients[i] * this.filter[i];\n    }\n\n    this.filter.shift();\n    this.filter.unshift(out);\n\n    return out;\n  }\n\n  /**\n   * Runs a list of values through the filter and returns an array of each step\n   */\n  run(start: number, values: number[]) {\n    const current = this.filter.slice(0);\n    const toProcess = values.slice(0);\n    this.reset(start);\n    const out: number[] = [];\n\n    while (toProcess.length > 0) {\n      out.push(this.stream(toProcess.shift() || 0));\n    }\n\n    // Reset the filter back to where it was\n    this.filter = current;\n\n    return out;\n  }\n}\n","export class PascalTriangle {\n  /** Contains the triangles elements [[1], [1, 1], [1, 2, 1], etc] */\n  elements: number[][];\n\n  constructor(levels: number) {\n    if (levels === 0) return;\n    const elements: number[][] = [[1]];\n    const _levels = levels - 1;\n\n    // i will be the index pointing to the previous row\n    for (let i = 0; i < _levels; ++i) {\n      const previous = elements[i];\n      const row = [1];\n\n      for (let k = 0, endk = previous.length - 1; k < endk; ++k) {\n        row.push(previous[k] + previous[k + 1]);\n      }\n\n      row.push(1);\n      elements.push(row);\n    }\n\n    this.elements = elements;\n  }\n\n  /**\n   * Tries to generate a gaussian kernal based on the pascal triangle where the kernal has so many elements\n   * To get a higher quality kernal trim off the ends of the triangle's row but keep the kernal number.\n   * This causes a deeper triangle to be calculated.\n   */\n  gaussianKernal(size: number, trim: number) {\n    const toTrim = trim * 2;\n    let row: number[] = [];\n\n    // Loop until we hit a row with enough elements to make the kernal\n    for (\n      let i = 0, end = this.elements.length;\n      i < end && this.elements[i].length - toTrim <= size;\n      ++i\n    ) {\n      row = this.elements[i];\n    }\n\n    // Make sure the elements matches the requested elements size exactly\n    if (row.length - toTrim !== size) {\n      console.warn(\n        'Error in pascal triangle gaussian kernal',\n        'Requested size',\n        size,\n        'Row',\n        row,\n        'Trim amount',\n        trim,\n        'Elements',\n        this.elements\n      );\n    }\n\n    // Copy and remove trimed elements\n    let kernal = row.slice(trim, row.length - trim);\n    // Get the new total of the row\n    const total = kernal.reduce((prev, next) => next + prev, 0);\n    // Normalize the kernal\n    kernal = kernal.map(value => value / total);\n\n    return {\n      kernal,\n      total,\n    };\n  }\n}\n","import { PascalTriangle } from './pascal-triangle';\n\nexport interface IGaussianBlurOptions {\n  /** Number of samples taken per data slot */\n  kernalSize: number;\n  /** Number of times the blur is applied */\n  passes: number;\n}\n\nconst { min, max } = Math;\n\nfunction clamp(val: number, minVal: number, maxVal: number) {\n  return max(min(val, maxVal), minVal);\n}\n\n/**\n * Performs a gaussian blur on a set of numerical data.\n */\nexport class GaussianBlur {\n  // This is a blur kernal used for blending\n  private kernal: number[];\n  // These are the options for the blur operation\n  options: IGaussianBlurOptions;\n\n  constructor(options: IGaussianBlurOptions) {\n    this.options = options;\n    this.update(options);\n  }\n\n  /**\n   * Applies the blur to the input data, returns a blurred version without affecting the source.\n   */\n  generate(\n    data: number[][],\n    offsetLeft: number = 0,\n    offsetTop: number = 0,\n    offsetRight: number = 0,\n    offsetBottom: number = 0\n  ) {\n    if (!data || !data[0] || !data[0].length) return data;\n\n    const { passes } = this.options;\n    const kernal = this.kernal;\n    const outPass = data.map(col => col.slice(0));\n    const width = data.length;\n    const height = data[0].length;\n\n    const offsets: { [key: number]: number[] } = {\n      1: [0],\n      3: [-1, 0, 1],\n      5: [-2, -1, 0, 1, 2],\n      7: [-3, -2, -1, 0, 1, 2, 3],\n      9: [-4, -3, -2, -1, 0, 1, 2, 3, 4],\n    };\n    const offset = offsets[kernal.length];\n\n    if (!offset) {\n      console.warn('No offset suitable for kernal size');\n      return data;\n    }\n\n    // Instantiate our vertical pass so we don't recreate every pass\n    const verticalPass: number[][] = [];\n    for (let x = 0; x < width; ++x) {\n      verticalPass.push([]);\n    }\n\n    for (let blurCount = 0; blurCount < passes; ++blurCount) {\n      // After the octaves have been loaded in, we can blur filter the result\n      let value;\n      let sample;\n\n      // Vertical Gaussian blur pass\n      for (let x = offsetLeft, endx = width - offsetRight; x < endx; ++x) {\n        const outCol = verticalPass[x];\n        const inCol = outPass[x];\n\n        for (let y = offsetTop, endy = height - offsetBottom; y < endy; ++y) {\n          value = 0;\n\n          for (let k = 0, endk = kernal.length; k < endk; ++k) {\n            sample = clamp(y + offset[k], 0, endy - 1);\n            value += (inCol[sample] || 0) * kernal[k];\n          }\n\n          outCol[y] = value;\n        }\n      }\n\n      // Horizontal Gaussian blur into our perlin data\n      for (let x = offsetLeft, endx = width - offsetRight; x < endx; ++x) {\n        const outCol = outPass[x];\n\n        for (let y = offsetTop, endy = height - offsetBottom; y < endy; ++y) {\n          value = 0;\n\n          for (let k = 0, endk = kernal.length; k < endk; ++k) {\n            sample = clamp(x + offset[k], 0, endx - 1);\n            value += ((verticalPass[sample] || [])[y] || 0) * kernal[k];\n          }\n\n          outCol[y] = value;\n        }\n      }\n    }\n\n    return outPass;\n  }\n\n  update(options: Partial<IGaussianBlurOptions>) {\n    Object.assign(this.options, options);\n\n    if (options.kernalSize) {\n      // This is a blur kernal that will be used for sampling the zoomed in octaves\n      this.kernal = new PascalTriangle(15).gaussianKernal(\n        options.kernalSize,\n        2\n      ).kernal;\n    }\n  }\n}\n","import { Vec2 } from './types';\n\nexport function scaleLinear(domain: Vec2, range: Vec2) {\n  return function(x: number) {\n    return (\n      ((x - domain[0]) / (domain[1] - domain[0])) *\n      (range[1] - range[0] + range[0])\n    );\n  };\n}\n","import { GaussianBlur } from './gaussian-blur';\nimport { scaleLinear } from './scale-linear';\nimport { Vec2 } from './types';\n\nconst { abs, floor, max, min, random } = Math;\n\nexport interface IPerlinOptions {\n  /** Output width */\n  width: number;\n  /** Output height */\n  height: number;\n  /** The amount of blurring to apply to the combined octaves */\n  blendPasses: number;\n  /**\n   * An octave is the start of perlin noise with a gaussian noise map. Each octave should be smaller\n   * than the end result. The octave is then scaled up then averaged with the\n   * other octaves. Octaves closer to the output size creates greater detail in regions, while\n   * octaves that are smaller creates larger features.\n   *\n   * Octaves are in the format [width, height]\n   */\n  octaves: Vec2[];\n  /**\n   * This sets the values that should appear within the perlin dataset.\n   */\n  valueRange: Vec2;\n}\n\n/**\n * This generates a 2d plane of perlin noise that is gray scale with values\n * that are 0 - 1.\n */\nexport class PerlinNoise {\n  /** The blurring kernal used to blur the data */\n  private blur: GaussianBlur;\n  /** The perlin data with values 0 - 1 */\n  data: number[][];\n  /** Used for debug rendering the output */\n  private debugContext: HTMLCanvasElement;\n  /** The options used to construct the data */\n  options: IPerlinOptions;\n\n  get width() {\n    return this.options.width;\n  }\n\n  get height() {\n    return this.options.height;\n  }\n\n  /**\n   * Provide the output size, and the size of the octaves generated.\n   */\n  constructor(options: IPerlinOptions) {\n    this.options = options;\n    this.blur = new GaussianBlur({\n      passes: options.blendPasses,\n      kernalSize: 9,\n    });\n\n    this.update(options);\n  }\n\n  /**\n   * Generates a new perlin dataset\n   */\n  async generate() {\n    const { width, height, octaves, valueRange } = this.options;\n    // This will contain the end perlin result\n    let perlin: number[][] = [];\n\n    // Loop through each octave and multiply it into the perlin output\n    octaves.forEach(octave => {\n      // Start with a smaller sized map of pure gray scale noise\n      const small: number[][] = [];\n      const smallWidth = octave[0];\n      const smallHeight = octave[1];\n      const scaleX = scaleLinear([0, width], [0, smallWidth]);\n      const scaleY = scaleLinear([0, height], [0, smallHeight]);\n\n      // Make the octave base\n      for (let x = 0; x < smallWidth; ++x) {\n        const col: number[] = [];\n        small.push(col);\n\n        for (let y = 0; y < smallHeight; ++y) {\n          col.push(random());\n        }\n      }\n\n      // Sample the octave into the size of the output perlin image\n      for (let x = 0; x < width; ++x) {\n        const col = (perlin[x] = perlin[x] || []);\n\n        for (let y = 0; y < height; ++y) {\n          col[y] = (col[y] || 1) * small[floor(scaleX(x))][floor(scaleY(y))];\n        }\n      }\n    });\n\n    // Run through the perlin noise data with our blur filter\n    perlin = this.blur.generate(perlin);\n\n    // We now normalize the ranges to keep details brighter\n    // We also make the data within each cell reflect the data range\n    // that is specified\n    let maxVal = -1;\n    const range = valueRange[1] - valueRange[0];\n    const base = valueRange[0];\n\n    for (let x = 0; x < width; ++x) {\n      const col = perlin[x];\n\n      for (let y = 0; y < height; ++y) {\n        // First brigten up darkened areas\n        // perlin[x][y] *= 1 / (perlin[x][y] + 1);\n        // Now get the max value\n        maxVal = max(col[y], maxVal);\n      }\n    }\n\n    for (let x = 0; x < width; ++x) {\n      const col = perlin[x];\n\n      for (let y = 0; y < height; ++y) {\n        col[y] /= maxVal;\n        col[y] = col[y] * range + base;\n      }\n    }\n\n    this.data = perlin;\n  }\n\n  /**\n   * Will just ensure the data object is populated with a generation.\n   */\n  async generateOnce() {\n    if (!this.data) {\n      await this.generate();\n    }\n  }\n\n  /**\n   * Retrieves a rectangular sample from the perlin data.\n   * If a threshold is included, absolute values below it will be zero'ed out.\n   */\n  sample(\n    x: number,\n    y: number,\n    width: number,\n    height: number,\n    threshold?: number\n  ) {\n    const out: number[][] = [];\n\n    if (threshold) {\n      for (let i = x, end = min(this.data.length, x + width); i < end; ++i) {\n        out.push(\n          this.data[i]\n            .slice(y, y + height)\n            .map(value => (abs(value) > threshold ? value : 0))\n        );\n      }\n    } else {\n      for (let i = x, end = min(this.data.length, x + width); i < end; ++i) {\n        out.push(this.data[i].slice(y, y + height));\n      }\n    }\n\n    return out;\n  }\n\n  /**\n   * Update the options for the noise generation.\n   */\n  update(options: Partial<IPerlinOptions>) {\n    Object.assign(this.options, options);\n\n    if (options.blendPasses) {\n      this.blur.update({\n        passes: options.blendPasses,\n      });\n    }\n  }\n\n  /**\n   * Renders a canvas on the screen showing the generated output.\n   */\n  debug(threshold: number = 0, clear?: boolean) {\n    if (clear) {\n      if (this.debugContext) {\n        this.debugContext.remove();\n      }\n      return;\n    }\n\n    const canvas = document.createElement('canvas').getContext('2d');\n\n    if (canvas) {\n      const { valueRange } = this.options;\n      const element = canvas.canvas;\n      document.getElementsByTagName('body')[0].appendChild(canvas.canvas);\n      const width = (element.width = this.data.length);\n      const height = (element.height = this.data[0].length);\n      const data = canvas.getImageData(0, 0, width, height);\n      let index = 0;\n      const range = valueRange[1] - valueRange[0];\n      const base = valueRange[0];\n\n      if (threshold) {\n        for (let x = 0, end = this.data.length; x < end; ++x) {\n          const col = this.data[x];\n\n          for (let y = 0, endy = col.length; y < endy; ++y) {\n            const val = 255 * (abs(col[y]) > threshold ? 1 : 0);\n            data.data[index * 4] = val;\n            data.data[index * 4 + 1] = val;\n            data.data[index * 4 + 2] = val;\n            data.data[index * 4 + 3] = 255;\n            index++;\n          }\n        }\n      } else {\n        for (let x = 0, end = this.data.length; x < end; ++x) {\n          const col = this.data[x];\n\n          for (let y = 0, endy = col.length; y < endy; ++y) {\n            const val = 255 * ((col[y] - base) / range);\n            data.data[index * 4] = val;\n            data.data[index * 4 + 1] = val;\n            data.data[index * 4 + 2] = val;\n            data.data[index * 4 + 3] = 255;\n            index++;\n          }\n        }\n      }\n\n      canvas.putImageData(data, 0, 0);\n      element.style.position = 'fixed';\n      element.style.top = '0px';\n      element.style.left = '0px';\n      element.style.zIndex = '9999';\n\n      this.debugContext = element;\n    }\n  }\n}\n","export * from './FIR';\nexport * from './gaussian-blur';\nexport * from './pascal-triangle';\nexport * from './perlin-noise';\nexport * from './types';\n"]}